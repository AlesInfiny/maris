---
title: 概要編
description: AlesInfiny Maris を利用することで構築できるアプリケーションの概要を、アプリケーション形態ごとに説明します。
---

# 構成管理 {#top}

## ソールコード管理 {#source-code-management}

AlesInfiny Maris では、ソースコードの管理に Git を推奨しています。 Git を採用するメリットは以下の通りです。

- 多くの ALM ツールが Git に対応しているため、連携が容易
- 分散型バージョン管理ツールのため、ローカル環境に中央リポジトリのクローンを作成しオフラインでも作業が可能

### ブランチ戦略 {#branch-strategy}

ブランチ運用方針は、プロジェクトの規模やチームの体制によって多種多様です。そのため適したブランチ運用をすることが、開発効率やコードの品質、可用性を高めることにつながります。
代表的なブランチ戦略として、[git-flow](https://nvie.com/posts/a-successful-git-branching-model/) 、[GitHub Flow](https://docs.github.com/ja/get-started/quickstart/github-flow) などが挙げられます。
これらをベースとして、以下のような観点でプロジェクトに適したブランチ戦略を定めましょう。

- 各機能開発の修正内容の差分整理が必要

    誰がどの機能に対していつどのような修正をしたか、を整理するため開発する機能ごとにブランチを作成します。 ALM ツールを採用している場合、このブランチにイシューを紐づけることで、修正が必要になった原因や背景を詳細に記録できます。

- リリースバージョンの管理
  
    - 結合・システムテストが完了している安定したバージョンをリリースする

        リリースするバージョン単位で develop ブランチを作成し開発・修正内容をマージします。 develop ブランチでの結合・システムテストの完了後に main ブランチへマージすることで常に main ブランチを安定した状態で保つことができます。

        develop ブランチを作成しない方針の場合、システムテスト完了後の main ブランチからリリースブランチを作成することで、安定したリリース版として保つことが可能です。この方法では各リリースバージョンをそれぞれ管理できます。

        常に最新のプログラムのみをリリースする場合は、リリースブランチにシステムテスト完了後の main ブランチを統合する方法も考えられます。

    - main ブランチでリリースバージョンを管理する

        プログラムの安定性よりも、新機能の開発・既存機能の修正への対応が重視されておりリリース頻度が高い場合、 main ブランチと開発ブランチで運用するシンプルなブランチ戦略を取ることも考えられます。この場合は、リリース時点での main ブランチの状態に対して、タグを付与してバージョン管理します。

- main ブランチや develop ブランチに破壊的な変更をマージしてしまう可能性を排除する

    main ブランチや develop ブランチへのマージには、開発者の意図に関わらず破壊的な変更が含まれる、という可能性があります。多くの ALM ツールにはこれを防ぐために、マージする際に他のメンバーに承認を求めるプルリクエストを発行する機能があります。プルリクエストでは以下のような項目のブランチポリシーを設定し、コードの品質を高く保ちます。

    - レビュアーの数：リポジトリの管理者〇人
    - コードレビューのコメントがすべて解決済みになっている
    - ビルドマシンでコードのビルドができる
    - ビルドマシンで単体テストが全件通過する

### 改行コード {#line-break-code}

AlesInfiny Maris では、通常 Git のリモートリポジトリ内の改行コードが LF で統一されることから、ローカルリポジトリの改行コードも LF に統一する方針を採用しています。
各ツール・エディターの設定を以下のようにします。

- Git

    Git はチェックアウトする時、テキストファイルの改行コードを CRLF に自動変換することがあります。
    以下のコマンドを実行し、チェックアウト時の CRLF への自動変換を無効化し、コミット時は LF へ自動変換するように設定します。

    ```bash
    git config --local core.autocrlf input
    ```

    ただしこれらの方法は Git の設定を開発者自身が行わなければいけないため、改行コードが開発者の環境によって混在する可能性があります。
    そのため .gitattributes を利用して、ソースコードの改行コードを強制的に LF に変換するように設定します。

    ```text title=".gitattributes"
    * text=auto eol=lf
    ```

- Visual Studio

    Visual Studio はデフォルトで改行コードを CRLF に変換します。
    これを無効化するために、プロジェクトに editorconfig を作成し `end_of_line = lf` を追加します。

    ```text title=".editorconfig"
    [*]
    end_of_line = lf
    ```

- Visual Studio Code

    プロジェクトで共通の設定をするため、 ワークスペースで設定します。 .code-workspace ファイルへ以下のように設定します。

    ```json title=".code-workspace"
    {
        settings: {
            "files.eol": "\n"
        }
    }
    ```

    またワークスペースを作成しない場合は、フォルダー単位で設定します。対象のフォルダーで .vscode/settings.json ファイルを作成し、以下のように設定します。

    ```json title=".vscode/settings.json"
    {
        "files.eol": "\n"
    }
    ```

- OpenAPI

    OpenAPI の NSwag で生成されるコードの改行コードは、デフォルトで CRLF です。
    そのため、改行コードを LF にするには、 nswag.json へ以下の設定を追加します。

    ```json title="nswag.json"
    {
        "documentGenerator": {
            "aspNetCoreToOpenApi": {
                "newLineBehavior": "LF"
            }
        }
    }
    ```

## 推奨するリポジトリ構造 {#repository-structure}

1 つのシステムの中に複数のプロジェクトやパッケージが存在する場合、リポジトリ管理の方針を定めます。
単一のリポジトリで管理する mono-repo とそれぞれ個別のリポジトリで管理する poly-repo ( multi-repo ) という管理方法があります。

- mono-repo のメリット
    - プロジェクト間のリソースの共有、すなわち横断した変更が容易
    - プロジェクトを横断したテストが容易
    - システムの全体把握が容易
- poly-repo のメリット
    - 開発者自身が作業するリポジトリに集中できるため開発効率が向上  
    - リポジトリの肥大化の防止

AlesInfiny Maris では mono-repo 構造を推奨します。
マイクロサービス開発など、各プロジェクトの独立性が高く、プロジェクトごとに採用する技術要素が全く異なる場合は、 poly-repo を検討してください。
