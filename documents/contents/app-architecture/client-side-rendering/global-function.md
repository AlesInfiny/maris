---
title: CSR 編
description: クライアントサイドレンダリングを行う Web アプリケーションのアーキテクチャについて解説します。
---

# 全体処理方式 {#top}

クライアントサイドレンダリング方式のアプリケーション全体で考慮すべきアーキテクチャについて、その実装方針を説明します。

## 例外処理方針 {#exception-policy}

<!-- ## サーバーサイドの例外処理 -->

## クライアントサイドの例外処理方針 {#frontend-error-handling}

クライアントサイドは、ユーザーが操作する、ログの取得が難しいなど、サーバーサイドとは異なる特性があります。
しかし例外処理方針としては、サーバーサイドと同様に正常なフローに復帰できるかどうかを最も重要な観点とし、そのためにどこで例外を捕捉しどのようにユーザーへ通知するかを検討します。

### 例外の種類 {#exception-types}

クライアントサイドの例外は、業務例外とシステム例外の 2 種類に分けて考えます。 API 通信で発生する例外については、ステータスコードが 40x のエラーを業務例外、 50x のエラーをシステム例外として扱います。
サーバーがリクエストを受理できた場合は、業務例外として扱い、サーバーがリクエストを受理できなかった場合は、システム例外として扱います。

### 例外の捕捉 {#catch-exceptions}

クライアントサイドで発生する例外は、以下のようなケースが考えられます。

- ユーザーが操作した際に発生する例外
- API 通信で発生する例外
- システムエラー
- ネットワークエラー

例外の発生が予測できる箇所では、基本的な同期処理は `try-catch` 、非同期処理は `catch` メソッドを利用します。予期せぬ例外が発生した場合は、 Vue.js の `app.config.errorHandler` や JavaScript の `window.onerror` といったグローバルエラーハンドリングで例外を捕捉します。

| 例外の種類 | ハンドリング方法 |
| ---------- | ---------------- |
| Vue コンポーネント内で発生する例外 | `app.config.errorHandler` |
| 一般的な JavaScript エラーや構文エラー | `window.onerror` |
| 非同期処理で発生する例外 | `window.onunhandledrejection` |

<!-- #### API 通信で発生する例外 {#api-connection-error}

クライアントサイドで最も多く発生する例外は、 API 通信で発生する例外です。その要因は、ネットワークエラーやサーバーエラー、ユーザーの入力エラーなど様々であるため、全ての例外に対処することは難しいです。
なお API 通信には Axios を利用していることを前提としています。

API 通信で発生する例外に対して、ステータスコードに対する共通処理や、エラー解析などの共通処理は axios.interceptors.response で行います。



ステータスコードでエラーを判断できる場合は、それに応じた処理を行う
ステータスコードだけでは判断できず、レスポンスの中身を見る必要がある場合は、それに応じた処理を行う
API 設計にぶん投げたい

401 番(認証エラー)であれば、ログイン画面へ遷移する
500 番　ただの失敗にする
ネットワークエラー　500番+レスポンス無し　失敗フロー

失敗フローを用意することが大事？　レスポンス→共通処理→個別失敗処理 -->

### 例外の処理 {#error-handling}

クライアントサイドの例外処理では、ユーザーが自身で対応できるか、という観点が重要になります、
たとえばセッションタイムアウトになるといったようなケースではユーザーが再度ログインすることで対処できます。
一方で、 WebAPI サーバー内で予期しない問題が発生するといったケースでは、ユーザー自身では問題を解決できず、開発者に問い合わせをするようなフローが考えられます。

このようにクライアントサイドでは、ユーザーが例外を知りどのような対応をするか、ということに注目しハンドリングや通知方法を決定します。

発生した例外の通知方法は以下のようなものがあります。

- ユーザー向けの通知
    - エラーページへの遷移
    - ポップアップ等の画面遷移を伴わない通知
- 開発者/運用者向けの通知
    - コンソールログ
    - ログ収集ツールへの送信

ユーザー向けの通知では、ユーザーがどのような対応をできるかを考慮し、適切な通知方法を選択します。例えば、クライアントサイドで発生したエラーに対して、開発者の対応が必要な場合は、エラーメッセージに加えて問い合わせ先やエラーコードなどを通知することが望ましいです。

コンソールログへの出力は原則開発環境のみとし、本番環境では出力しないようにします。ただし、ユーザーが限定されるような要件でエラー詳細を隠す必要がないシステムであれば、本番環境でもコンソールログを出力することがあります。

<!-- 
エラーの種類を通知
ネットワークエラーかサーバーダウンか
サーバーからレスポンスがあるかないか
サーバーからのレスポンスがエラーかどうか
→詳細はここでは書かない 
-->

#### API 通信で発生する例外処理フロー {#api-connection-error-flow}

クライアントサイドで最も多く発生する例外は、 API 通信で発生する例外です。その要因は、ネットワークエラーやサーバーエラー、ユーザーの入力エラーなど様々であるため、全ての例外に対処することは難しいです。
API 通信で発生する例外についてはいくつかの段階に分けて処理します。なお API 通信には Axios を利用していることを前提としています。

<!-- 
- API 通信で発生する例外をシステム例外(500番)と業務例外(400番)に分けて処理すべきか
それとも API 例外として別区分にするか
- API 通信で発生する例外の共通処理は axios.interceptors で行なうため JavaScript 全体のエラーハンドリングとは別に考えたほうがよいのかも
- 共通処理でやること
 -->

1. API レスポンスに対する共通処理

    HTTP ステータスコードに対する共通処理を [axios.interceptors.response :material-open-in-new:](https://axios-http.com/ja/docs/interceptors) に集約します。`axios.interceptors.response` は、レスポンスの受信後、 `then` や `catch` の処理の前に共通処理を挟むことができます。
    ここで行う共通処理については以下のようなものが考えられます。

    - 401 Unauthorized であれば、ログイン画面へ遷移する。
    - エラー解析モジュールにエラー情報を格納する。
    <!-- - 非機能 API ではエラーを握りつぶす -->

    ```mermaid
        sequenceDiagram
        participant C as Vue コンポーネント
        participant A as Axios.Post
        participant I as Axios.interceptors.response
        participant S as サーバー

        C->>A: API リクエスト呼び出し
        A-)S: API リクエスト
        S--)I: 401 Unauthorized
        rect rgba(255, 0, 0, 0.5)
            I->>C: 共通処理：ログイン画面へ遷移
        end
    ```

1. API レスポンスの例外に対する処理

    API 通信で発生する例外については、 API 通信のレスポンスハンドリングで個別に処理します。
    リクエストに不備がある、といったユーザーが対応できるようなエラーについては、対応方法をユーザーに通知します。
    通知方法はポップアップやトースト通知などの入力を阻害しない方法か、やむを得ずエラー画面に遷移するかを適宜選択することが望ましいです。

    また、発生したエラーを解析するために、以下の方法が考えられます。

    - エラー番号やエラーメッセージを通知し、開発者が問合せるための情報を提供する
    - ユーザーの状況やエラー内容をログ収集ツールに送信する

    ```mermaid
        sequenceDiagram
        participant C as Vue コンポーネント
        participant A as Axios.Post
        participant I as Axios.interceptors.response
        participant S as サーバー

        C->>A: API リクエスト呼び出し
        A-)S: API リクエスト
        S--)I: 400 Bad Request
        I->>A: エラー情報の解析
        rect rgba(255, 0, 0, 0.5)
            A->>C: エラー情報の通知
        end
    ```
<!--
    
    - 404 番(リソースが見つからない)であれば、 Not Found ページへリダイレクトする、もしくはトーストで通知する。　一律でしてはいけなさそう
    - 500 番(サーバーエラー)であれば、エラーページへリダイレクトする。

    400 番は、バリデーションエラーなどの業務例外であるため、個別で処理します。 
    エラーをstoreに格納しておく→通知するかどうかはエラーの中身で判断　という考え方もある
    業務エラーとして置き換える
    非機能APIで共通処理でエラーハンドリングをしたくない
 -->

## ログ出力方針 {#logging-policy}

（今後追加予定）

<!-- ### トランザクション管理 -->

<!-- ## 入力値検査方針 {#validation-policy} -->

<!-- ### セキュリティ対策 -->

## ヘルスチェック機能の実装方針 {#health-check-implementation}

AlesInfiny Maris では、 Web API を通じてシステムが正常稼働中か確認します。
`Microsoft.Extensions.Diagnostics.HealthChecks` の機能を利用してヘルスチェック用の Web API を実装しています。

実装方法の詳細については、[ヘルスチェック API の実装](../../guidebooks/how-to-develop/dotnet/health-check-api.md) およびサンプルアプリケーションを参照してください。
また、ヘルスチェックの全体方針については、[ヘルスチェックの必要性](../overview/dotnet-application-processing-system.md#health-check-necessity)を参照してください。

### API の仕様 {#api-specs}

ヘルスチェック用の Web API にリクエストを送信すると、アプリケーションおよび関連するデータベース等の稼働状況が確認されます。

アプリケーションとデータベース等の外部サービスが全て正常稼働している場合を正常状態とします。
アプリケーションとデータベース等の外部サービスのいずれかに異常がある場合を異常状態とします。

正常状態の場合は、 HTTP 200 のレスポンスを返却し、異常状態の場合は HTTP 503 のレスポンスを返却します。

|      HealthStatus      | ステータスコード | レスポンスボディ |                   詳細                   |
| ---------------------- | ---------------- | ---------------- | ---------------------------------------- |
| HealthStatus.Healthy   | 200              | Healthy          | サーバーがリクエスト受付可能             |
| HealthStatus.Unhealthy | 503              | Unhealthy        | サーバーがリクエスト受付不可/停止状態   |

[`HealthStatus` :material-open-in-new:](https://learn.microsoft.com/ja-jp/dotnet/api/microsoft.extensions.diagnostics.healthchecks.healthstatus){ target=_blank } をどのように使い分けるかについては、[HealthStatus の使い分け](../../guidebooks/how-to-develop/dotnet/health-check-api.md#health-status) を参照してください。

また、ロードバランサーによってはヘルスチェック実行時の HTTP メソッドが限られるため、 HTTP GET/HEAD メソッドに対応しています。

### 検証ロジックの追加 {#add-health-check-logic}

ヘルスチェック API は Web プロジェクトのアプリケーションとしての稼働状況と、データベース等の利用/依存しているサービスの稼働状況を取りまとめてレスポンスを返します。
そのため、ヘルスチェック API 実行時に独自の検証ロジックを含める場合は、検証対象の外部サービスに依存するプロジェクトへ実装します。

図のように、外部サービスのヘルスチェックロジックはプレゼンテーション層にあたる Web プロジェクトに直接実装しません。
検証対象の外部サービスに対応するそれぞれのプロジェクトへ分割してロジックを追加し、 Web プロジェクトから参照するようにします。

![検証ロジックの配置](../../images/app-architecture/client-side-rendering/add-health-check-logic-light.png#only-light){ loading=lazy }
![検証ロジックの配置](../../images/app-architecture/client-side-rendering/add-health-check-logic-dark.png#only-dark){ loading=lazy }
